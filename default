#!/usr/bin/python
# -*- coding: utf-8 -*-

import logging
from logging import FileHandler
from wsgiref.handlers import CGIHandler
import os

from flask import Flask, Response, render_template

# move to home directory so
# dumptruck can find sqlite file
os.chdir('/home')
import scraperwiki

app = Flask(__name__)

# Log exceptions to http/error.txt
logger = FileHandler('/home/http/error.txt')
logger.setLevel(logging.WARNING)
app.logger.addHandler(logger)

# Avoid default Flask redirect when a
# URL is requested without a final slash
app.url_map.strict_slashes = False

# Get the "root" url path, because
# Flask isn't running at the domain root
path = os.environ['PATH_INFO']
root = '/'.join(path.split('/')[0:5])

# Stop extra whitespace creeping
# into Jinja templates
app.jinja_env.trim_blocks = True
app.jinja_env.lstrip_blocks = True

request_url = 'https://{}{}'.format(os.environ['HTTP_HOST'], os.environ['PATH_INFO'])


@app.route(root + "/")
def show_collections():
    tables = scraperwiki.sql.show_tables().keys()
    resp = Response()
    resp.headers['Content-Type'] = 'application/xml;charset=utf-8'
    resp.data = render_template('collections.xml', base_url=request_url, collections=tables)
    return resp


@app.route(root + "/<collection>/")
def show_collection(collection):
    # TODO: check that `collection` table actually exists
    entries = get_entries_in_collection(collection)
    resp = Response()
    resp.headers['Content-Type'] = 'application/xml;charset=utf-8'
    resp.data = render_template('collection.xml', base_url=request_url, collection=collection, entries=entries)
    return resp


def get_entries_in_collection(collection):
    rows = scraperwiki.sql.select('rowid, * FROM "{collection}"'.format(collection=collection))
    entries = []
    for row in rows:
        entries.append({
            'url': u"{}({})".format(request_url, row['rowid']),
            'rowid': row['rowid'],
            'cells': get_cells_in_row(row)
        })
    return entries


def get_cells_in_row(row):
    # `row` should be a dict, where the keys are
    # column names and the values are cell values
    cells = []
    for column, value in row.iteritems():
        cells.append({
            'column': column,
            'value': value,
            'type': get_cell_type(value)
        })
    return cells


def get_cell_type(value):
    if value is None:
        return 'Edm.Null'
    elif isinstance(value, float):
        return 'Edm.Double'
    elif isinstance(value, int):
        return 'Edm.Int32'
    elif isinstance(value, bool):
        return 'Edm.Boolean'
    else:
        # TODO: handle dates!! Edm.DateTime
        return 'Edm.String'


CGIHandler().run(app)
